<attachment contenteditable="false" data-atts="%5B%5D" data-aid=".atts-e99b9464-d8e6-4e63-828f-8c352053c7c4"></attachment><p>SurfaceFlinger服务负责管理Android 系统的帧缓冲区（Frame Buffer）、绘制Android 应用程序的UI；</p><p>SurfaceFlinger服务运行于System进程中；与Application之间通过Binder通信</p><p>SurfaceFlinger与Application之间通过SharedClient传递UI数据 </p><p>一个Application 对应一个SurfaceFlinger服务的Client对象，以及一个SharedClient对象；</p><p>一个SharedClient至多有31个SharedBufferStack; </p><p>SharedClient被封装在Surface.cpp中的SurfaceClient中(单例)</p><p>一个SharedBufferStack对应一个Surface；（也就是一个Application最多有31个Surface）</p><p>一个SharedBufferStack可能有多个Buffer区(所以叫Stack，有2-16个)</p><p>SharedBufferStack中的Buffer区只保存UI元数据和一个GraphicBuffer，GraphicBuffer保存真正的UI数据；在使用中的Buffer区才会有GraphicBuffer</p><p>GraphicBuffer 是什么？图形缓冲区，包含一个FrameBuffer或者匿名共享内存(Ashmem)，通过Gralloc模块分配；包含FrameBuffer的图形缓冲区是在SurfaceFlinger中使用的（用来绘制到显示屏），而包含Ashmem的图形缓冲区既可以在SurfaceFlinger中使用也可以在其他进程中使用</p><h1>Surfa</h1><h1>Application创建Surface</h1><ol><li>Application与SurfaceFlinger建立连接: ISurfaceComposer::createClientConnection() ; 包含一个SharedClient</li></ol><h1>Application更新Surface</h1><ol><li>找到Surface对应的SharedBufferStack</li><li>从SharedBufferStack中取出一个空闲的Buffer</li><li>请求SurfaceFlinger给Buffer分配一个GraphicBuffer</li><li>Application往GraphicBuffer写入UI数据后将Buffer放回SharedBufferStack</li><li>Application通知SurfaceFlinger绘制UI： ISurfaceComposer::signal()</li><li>SurfaceFlinger使用完Buffer之后，重新放回SharedBufferStack 空闲队列</li></ol><p><br></p>